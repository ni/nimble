# Table Row Selection HLD

## Problem Statement

The nimble-table should support selecting rows. Row selection should be configurable such that a client can enable single-row selection, multi-row selection, or no selection. A client of the table should be able to get the current selection from the nimble-table element and should also be notified when the selection changes.

## Out of scope of this HLD

The following items are out of scope of this HLD:

-   The table will not support programmatically selecting grouped rows. This feature can be implemented in the future if desired, but the first step of adding this feature will need to be exposing row IDs for grouped rows.
-   Any implication that data hierarchy has on row selection is out of scope for this HLD.

## Links To Relevant Work Items and Reference Material

-   [#856 Selection support in the table](https://github.com/ni/nimble/issues/856)
-   [Table README](./README.md)
-   [Table Design Doc](https://xd.adobe.com/view/5b476816-dad1-4671-b20a-efe796631c72-0e14/screen/d389dc1e-da4f-4a63-957b-f8b3cc9591b4/specs/)
-   [Table interactions UX Spec](https://xd.adobe.com/view/6f3be15d-8503-4f1f-54b9-5bc27955b3e4-190a/)

## Implementation / Design

### API

There will be a new attribute on the table named `selection-mode`. It will be of type `TableRowSelectionMode` as shown below, and it will default to `TableRowSelectionMode.none`.

```ts
export const TableRowSelectionMode = {
    none: undefined,
    single: 'single',
    multiple: 'multiple'
} as const;
export type TableRowSelectionMode =
    (typeof TableRowSelectionMode)[keyof typeof TableRowSelectionMode];
```

When row selection changes due to a user interaction, the table will emit a `selection-change` event. The event will not be emitted if selection changes due to a non-user action, such as updating the data. The `detail` of the `selection-change` event will be of type `TableRowSelectionEventDetail`, which will be defined as follows:

```ts
export interface TableRowSelectionEventDetail {
    selectedRecordIds: string[];
}
```

In the case where grouping is enabled, it is possible that a grouping row can be visualized as selected because all of its child rows are selected. It is important to note that because the grouping row does not have a record associated with it, it will never be returned as part of the `selectedRecordIds` array in the event detail. Instead, each of its selected child rows will have their record ID included in the `selectedRecordIds` array.

The table will have `getSelectedRecordIds(): string[]` and `setSelectedRecordIds(recordIds: string[]): void` functions to get and set the current selection in the table. The `get` function will convert TanStack's selection state, which is a map of row IDs to boolean, to a string array of the IDs in the map with a value of `true`. The `set` function will update TanStack's selection state to be the record IDs passed to the function. Any record IDs that do not exist will be removed from the selection prior to updating TanStack's state. Calling `setSelectedRecordIds()` with an empty array will clear the selection.

The table will only support selection when it has an `id-field-name` configured on it. This is for a few reasons:

-   Record IDs are meaningless when an `id-field-name` is not set. When that attribute is not set, the IDs are generated by TanStack, and no assumptions about their values should be made by a client application. Therefore, a client would not be able to do anything with the array of record IDs emitted from the `selection-change` event when `id-field-name` is not set.
-   Selection within TanStack will be maintained using record IDs. The selection behavior will be unexpected and non-deterministic if a record in the table does not have a static ID associated with it.
-   The selection state of TanStack needs to be updated when the data is updated to ensure that no rows are configured as selected when they don't exist in the data set anymore. Removing the selection state for removed records will be more straight forward when an `id-field-name` is set because the record IDs can be determined using the data passed to `setData` alone. When using IDs generated by TanStack, first TanStack would need to be updated with the new data, then the generated ID could be pulled from each TanStack row, and only then could the new selection state be determined and set on the underlying TanStack table.

When new data is set on the table, the set of selected rows needs to be evaluated to remove the state of rows whose record no longer exists in the data. When the record IDs are invalid for any reason, the selection state will not be modified based on the new data. When the data updates again to have valid IDs, the selection state will then be updated. When `id-field-name` is changed, the selection state will be cleared (i.e. no rows selected) because the set of old selected record IDs will be invalidated by each record potentially having a new ID.

### General behavior and design

Selection disabled

-   Rows will not have a hover state
-   No selection checkboxes will be visible within the table
-   Clicking on a row does nothing
-   Opening the action menu for a row does not mark the row as selected

Single selection

-   Rows have a hover state
-   No selection checkboxes will be visible within the table
-   Selection will be indicated by a changed row background color
-   Selection is set by clicking on a row; clicking a new row changes selection to that row
-   The menu button associated with an action menu is visible for the selected row even if it is not hovered
-   Opening the action menu for a row ensures that row is selected
-   Keyboard interactions:
    -   SPACE: Select/deselect the focused row

Multiple selection

-   Rows have a hover state
-   Selection checkbox is visible on each non-grouped row with the following behavior:
    -   The checkbox will be checked if the row is selected
    -   The checkbox will not be checked if the row is not selected
    -   Clicking the checkbox adds/removes the row from the set of selected rows without affecting selection of other rows
-   Selection checkbox is visible on each grouped row with the following behavior:
    -   The checkbox will be checked if all rows in the group are selected
    -   The checkbox will not be checked if no rows in the group are selected
    -   The checkbox will be in the indeterminate state if some, but not all, rows in the table are selected
    -   Clicking the checkbox toggles the selection for all rows in that group
-   Selection checkbox is visible in the table's header with the following behavior:
    -   The checkbox will be checked if all rows in the table are selected
    -   The checkbox will not be checked if no rows in the the table are selected
    -   The checkbox will be in the indeterminate state if some, but not all, rows in the table are selected
    -   Clicking on the checkbox toggles the selection for all rows in the table
-   Selection of non-grouped rows is additionally indicated by a changed row background color
-   Clicking a non-grouped row makes it selected and deselects any rows that previously were selected
-   Multiple non-grouped rows can be selected using CTRL+click and SHIFT+click
-   The menu-button associated with an action menu is visible for all selected rows even when they are not hovered
-   Opening the action menu for a row ensures that row is selected:
    -   If that row was already selected, the action menu is associated with all selected rows. The record IDs for each selected row will be included in the `action-menu-toggle` event detail.
    -   If that row was not already selected, the selection changes to _only_ that row. All other rows are deselected. The action menu is only applied with the single row it was opened on. The record ID for only the single row will be include in the `action-menu-toggle` event detail.
-   Keyboard interactions:
    -   SPACE: Select/deselect the focused row
    -   CTRL + SPACE: Multi-select/multi-deselect row
    -   SHIFT + SPACE: Select rows between selected and focused
    -   SHIFT + ARROW DOWN: Select/multiselect row(s) below
    -   SHIFT + ARROW UP: Select/multiselect row(s) above
    -   CTRL + A: Select all rows

### Interfacing with TanStack

TanStack will be leveraged to maintain the state of which rows are selected, which grouped rows have some/all/no selection within them, and whether the table has any rows selected. TanStack will also help ensure that when `selection-mode` is set to `TableRowSelectionMode.single`, only one row can be selected at a time.

To achieve the desired behavior, TanStack will configured will the following options:

-   [enableRowSelection](https://tanstack.com/table/v8/docs/api/features/row-selection#enablerowselection) - function that returns `true` for non-grouped rows
-   [enableMultiRowSelection](https://tanstack.com/table/v8/docs/api/features/row-selection#enablemultirowselection) - `true` when `selection-mode` is set to `TableRowSelectionMode.multiple`
-   [enableSubRowSelection](https://tanstack.com/table/v8/docs/api/features/row-selection#enablesubrowselection) - `true`

As mentioned above, TanStack does not update the selection state when the data changes. Therefore, it will be the nimble table's responsiblity to ensure that the set of selected records only includes records that currently exist in the data when `setData()` is called and to clear the selection when `id-field-name` changes.

### Validation

The table will be invalid when a selection mode other than `TableRowSelectionMode.none` is set and an `id-field-name` is not set. A new `idFieldNameNotConfigured` key will be added to the `TableValidity` object to represent this invalid configuration.

### Accessibility

Accessbility guidance taken from [MDN role="row"](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/row_role)

-   Rows that are currently selected will have `aria-selected="true"` configured.
-   Rows that are currently not selected but can be selected will have `aria-selected="false"` configured.
-   When selection is not enabled in the table, `aria-selected` will not be set on any rows.

The guidance above applies to rows within a component with a role of `grid` or `treegrid`. However, the nimble table currently has a role of `table`. As part of this feature, the nimble table's role will be updated to `grid`.

## Alternative Implementations / Designs

### Modify TanStack configuration approach

Rather than specifying grouped rows as not selectable, we could have the TanStack options specify that all rows (including grouped rows) support selection. The downside of this approach is that the selection state within TanStack will include row IDs for grouped rows. Therefore, we would need to filter out IDs associated with grouped rows prior to returning the selection state to a client of the table.

### Allow selection on tables without an `id-field-name` set

Instead of having validation preventing enabling selection in the table without an `id-field-name`, the table could support selection while using generated IDs from TanStack. However, this would make deleting the selection state for removed rows more difficult, and it is also unlikely to enable easier use for a client because the record IDs associated with selection don't provide meaning to a client without `id-field-name` set.

## Open Issues

-   There is [an issue in TanStack](https://github.com/TanStack/table/issues/4759) with deselecting a grouped row with the proposed configuration. There is also [an open PR](https://github.com/TanStack/table/pull/4760) with a fix. If the issue isn't resolved within TanStack, we will need to put a workaround in the nimble-table.
